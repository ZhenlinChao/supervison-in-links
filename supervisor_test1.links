typename Message = [|ProcessFailed:Int |];
typename Id = Int;
typename Name = String;
typename Process = (processName: String);

var processlist =
  [(1, (processName = "worker1")),
   (2, (processName = "worker2"))];

fun failed(id,map) {
  switch (lookup(id, map)) {
    case Just(process) -> println("process Failed: "^^process.processName)
    case Nothing -> ()
  }
}

fun wrapper(f, supervisor, n) {
    var _ = spawn {
        try f() as x in {()}
        otherwise {
            supervisor ! ProcessFailed(n)
        }
    };
    ()
}

fun supervisor(fs) {
    var pid=self();
    var fsMap=mapi(fun(f,i) { 
        ignore(spawn{wrapper(f,pid,i+1)});
        (i+1,(process=f))
    }, fs);

    fun supervisionLoop(fs){
        receive {
            case ProcessFailed(int) -> 
                failed(int,processlist);
                switch (lookup(int, fsMap)) {
                    case Just(x) -> ignore(spawn{wrapper(x.process,pid,int)});supervisionLoop(fs)
                    case Nothing -> ()
                }
        }
    }
    supervisionLoop(fs)
}

# worker1 never raises a failure, and worker2 always raises a failure
fun worker1() {
    if(1+1<>2){
        raise
    }
    else{
        println("OK!")
    }
}

fun worker2() {
    if(1+1==2){
        raise
    }
    else{
        println("OK!")
    }
}

ignore(spawn { supervisor([worker1,worker2]) })
